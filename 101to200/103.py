"""
Project Euler Problem 103
=========================

Let S(A) represent the sum of elements in set A of size n. We shall call
it a special sum set if for any two non-empty disjoint subsets, B and C,
the following properties are true:

 1. S(B) != S(C); that is, sums of subsets cannot be equal.
 2. If B contains more elements than C then S(B) > S(C).

If S(A) is minimised for a given n, we shall call it an optimum special
sum set. The first five optimum special sum sets are given below.

n = 1: {1}
n = 2: {1, 2}
n = 3: {2, 3, 4}
n = 4: {3, 5, 6, 7}
n = 5: {6, 9, 11, 12, 13}

It seems that for a given optimum set, A = {a[1], a[2], ... , a[n]}, the
next optimum set is of the form B = {b, a[1]+b, a[2]+b, ... ,a[n]+b},
where b is the "middle" element on the previous row.

By applying this "rule" we would expect the optimum set for n = 6 to be A
= {11, 17, 20, 22, 23, 24}, with S(A) = 117. However, this is not the
optimum set, as we have merely applied an algorithm to provide a near
optimum set. The optimum set for n = 6 is A = {11, 18, 19, 20, 22, 25},
with S(A) = 115 and corresponding set string: 111819202225.

Given that A is an optimum special sum set for n = 7, find its set string.

NOTE: This problem is related to problems 105 and 106.
"""
from itertools import chain, combinations
import math


# set of 7 generated with the algorithm above applied to the optimal set of 6
set_7 = {20, 31, 38, 39, 40, 42, 45}

def validate_set(iterable):
    # get all subsets https://stackoverflow.com/questions/1482308/how-to-get-all-subsets-of-a-set-powerset
    subsets = chain.from_iterable(combinations(iterable, r) for r in range(1, len(iterable) + 1))
    subset_sums = set()
    sum_ranges = [[0,0] for _ in range(len(iterable) +1)] # keep track of max/min sum by set size to check rule 2
    for ss in subsets:
        ss_sum = sum(ss)
        if ss_sum in subset_sums:
            return False # sums of subsets cannot be equal
        subset_sums.add(ss_sum)
        rng = sum_ranges[len(ss)]
        if rng[0] == 0: # set min if this is the first set of this size
            rng[0] = ss_sum
        rng[0] = min(rng[0], ss_sum)
        rng[1] = max(rng[0], ss_sum)
    # check 1 passed, now validate ranges for check 2
    point = 0 # keep pointer, iterate over array, should be strictly increasing
    for i in range(1, len(sum_ranges)):
        this_range = sum_ranges[i]
        if point >= this_range[0]:
            return False
        point = this_range[1]
    return True


# brute force: test all possible sets of numbers with sum less than sum of set generated by algorithm in question
# first element of set is always increasing, so min element is 11
#print(sum(set_7))    = 255
# max is less than 255 - (11 + 12 + 13 + 14 + 15 + 16) = 174?

def try_to_find_set(set_min, max_sum, set_len, max_elem):
    if set_len < 1:
        return []
    if set_len == 1:
        for n in range(set_min, min(max_sum, max_elem)):
            yield [n]
    first_element_upper_bound = min(math.ceil(max_sum / set_len), max_elem)
    first_elem = set_min
    while first_elem < first_element_upper_bound:
        possible_next_numbers = try_to_find_set(first_elem+1, max_sum - first_elem, set_len-1, max_elem)
        for p_l in possible_next_numbers:
            if validate_set([first_elem]+p_l):
                yield [first_elem] + p_l
        first_elem += 1

def find_set(x):
    if x<1:
        return []
    elif x==1:
        return [1]
    elif x==2:
        return [1,2]
    else:
        min_elem = 1
        max_sum = 300
        first_element_upper_bound = math.ceil(max_sum / x)
        for f in range(min_elem, first_element_upper_bound):
            new_max_sum = max_sum - f
            second_element_upper_bound = math.ceil(new_max_sum / x-1)
            for s in range(f+1, second_element_upper_bound):
                max_el = f + s
                possible_sets = try_to_find_set(s+1, new_max_sum - s, x-2, max_el)
                for p in possible_sets:
                    try_set = [f,s] + p
                    if validate_set(try_set):
                        return try_set

s = find_set(7)
print("".join([str(c) for c in s]))
